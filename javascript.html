<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><link rel="preload" as="font" href="/_next/static/media/2aaf0723e720e8b9-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/8319b3630653a7b6.css" data-precedence="next"/><title>前端QA集锦</title><meta name="description" content="前端工程师面试题集锦｜web前端大厂面试真题｜网聚各类前端面试题目"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="any"/><meta name="next-size-adjust"/><meta name="baidu-site-verification" content="codeva-IHpkfWdf3A"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_0ec1f4 love"><nav class="main-nav-container" style="background-color:#1a1a1b;display:flex;align-items:center;color:#cecdcd;user-select:none"><div style="font-size:20px;user-select:none;padding:0 20px"><span style="color:#1e9bd3">前端</span> <span>.</span><span style="background-image:-webkit-linear-gradient(left, #a504f1, #edc03c);-webkit-background-clip:text;-webkit-text-fill-color:transparent">QA</span></div><ol style="display:flex;height:60px;line-height:60px;margin-left:200px"><li><a href="/html.html">HTML</a></li><li><a href="/css.html">CSS</a></li><li><a href="/javascript.html">JavaScript</a></li><li><a href="/framework.html">框架</a></li></ol></nav><div style="margin:40px auto 0;width:700px"> <ol><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>什么是闭包？ 闭包有哪些优缺点？</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。
        
        作用： 延长变量作用域、在函数的外部可以访问函数内部的局部变量，容易造成内层泄露，因为闭包中的局部变量永远不会被回收</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
js 的数据类型有哪些？
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">js 的数据类型分为基本数据类型（string、number、boolean、null、undefined、symbol）和复杂数据类型
基本数据类型的特点：直接存储在栈中的数据

复杂数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
图片懒加载是怎么实现的？
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">为图片设置默认图或背景图（一般作为骨架屏的一部分），同时监听其在与视口（viewpoint）的位置关系，判断其进入视口时或即将进入视口时，进行图片请求并替换掉默认的图像。

关于默认图：可以用真实的图片，也可以通过svg等，也可作为背景图等。
关于如何监听图像与视口的位置关系：可以通过监听滚动事件进而计算scrollTop；也可借助Intersection API，这样可以免除额外的计算</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
什么是symbol ？
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">ES6 引入新的原始数据类型 Symbol，表示独一无二的值
Symbol可作为对象的属性名，该属性无法通过常规的Object.keys()或for...in又或Object.getOwnPropertyNames来枚举。因此可以定义一些我们不想对外操作和访问的属性
还可用来定义常量，由于天生的唯一性，非常方便。如 const A= Symbol();const B=Symbol()</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
数据类型的判断有哪些方法？他们的优缺点及区别是什么？
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">typeof使用简单，但只能判断基本类型，无法区分object与null
instanceof 只能判断对象是否是某个构造函数的实例
通过.constructor 可获取对象的构造器（构造函数）,但改值可以被改写。
Object.prototype.toString.call 相对来说功能最全，返回一个字符串：[object Type]</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
什么是递归，递归有哪些优点或缺点？
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">递归： 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数
优点： 结构清晰、可读性强
缺点： 效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
call、apply、bind 三者的异同
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">共同点 :
都可以改变 this 指向;
不同点:
call 和 apply 会调用函数, 并且改变函数内部 this 指向, 并且call 和 apply传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递
bind 不会调用函数, 可以改变函 数内部 this 指向.</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
什么是深拷贝、什么是浅拷贝？
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
深拷贝： 会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。 深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</pre></div></div></div><div style="padding:14px;border-radius:6px;line-height:1.6;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);margin-bottom:14px"><p><span style="font-weight:bold">Q: </span><span>
js 的执行机制是怎么样的？
</span><a style="user-select:none;margin-left:10px;color:#0b4ead;cursor:pointer"><span>参考答案</span><svg xmlns="http://www.w3.org/2000/svg" class="arrow-icon" width="18" height="18px" viewBox="0 0 1024 1024" version="1.1"><path d="M728.223744 520.22784a42.467328 42.467328 0 0 1-11.393024 20.503552L374.90688 882.65728c-16.662528 16.662528-43.677696 16.662528-60.340224 0s-16.662528-43.677696 0-60.340224L626.449408 510.43328 314.614784 198.598656c-16.662528-16.662528-16.662528-43.677696 0-60.340224 16.661504-16.662528 43.676672-16.662528 60.3392 0L716.879872 480.18432c10.860544 10.860544 14.642176 26.120192 11.343872 40.04352z" fill="#323233"></path></svg></a></p><div class="answer-container" style="display:none;margin-top:8px"><div><span style="font-weight:bold">A: </span><pre style="white-space:pre-line">js 是一个单线程、异步、非阻塞 I/O 模型、 event loop 事件循环的执行机制
所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程， 某个异步任务可以执行了，该任务才会进入主线程执行。</pre></div></div></div></ol> </div><script src="/_next/static/chunks/webpack-22967df09f43b0b8.js" async=""></script><script src="/_next/static/chunks/c93363e4-0c8c4bed11ceb720.js" async=""></script><script src="/_next/static/chunks/159-9a94d88e5de85c4d.js" async=""></script><script src="/_next/static/chunks/main-app-cca566b25c5f9c56.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/2aaf0723e720e8b9-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/8319b3630653a7b6.css\",{\"as\":\"style\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":\"6550\",\"chunks\":[\"272:static/chunks/webpack-22967df09f43b0b8.js\",\"741:static/chunks/c93363e4-0c8c4bed11ceb720.js\",\"159:static/chunks/159-9a94d88e5de85c4d.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":\"3712\",\"chunks\":[\"272:static/chunks/webpack-22967df09f43b0b8.js\",\"741:static/chunks/c93363e4-0c8c4bed11ceb720.js\",\"159:static/chunks/159-9a94d88e5de85c4d.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":\"7807\",\"chunks\":[\"272:static/chunks/webpack-22967df09f43b0b8.js\",\"741:static/chunks/c93363e4-0c8c4bed11ceb720.js\",\"15"])</script><script>self.__next_f.push([1,"9:static/chunks/159-9a94d88e5de85c4d.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":\"5017\",\"chunks\":[\"272:static/chunks/webpack-22967df09f43b0b8.js\",\"741:static/chunks/c93363e4-0c8c4bed11ceb720.js\",\"159:static/chunks/159-9a94d88e5de85c4d.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/8319b3630653a7b6.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/javascript\",\"initialTree\":[\"\",{\"children\":[[\"category\",\"javascript\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"javascript\\\"}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L5\",[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\"}]],\"globalErrorComponent\":\"$6\",\"notFound\":[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"meta\",null,{\"name\":\"baidu-site-verification\",\"content\":\"codeva-IHpkfWdf3A\"}],[\"$\",\"body\",null,{\"className\":\"__className_0ec1f4 love\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"main-nav-container\",\"style\":{\"backgroundColor\":\"#1a1a1b\",\"display\":\"flex\",\"alignItems\":\"center\",\"color\":\"#cecdcd\",\"userSelect\":\"none\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"fontSize\":\"20px\",\"userSelect\":\"none\",\"padding\":\"0 20px\"},\"children\":[[\"$\",\"span\",null,{\"style\":{\"color\":\"#1e9bd3\"},\"children\":\"前端\"}],\" \",[\"$\",\"span\",null,{\"children\":\".\"}],[\"$\",\"span\",null,{\"style\":{\"backgroundImage\":\"-webkit-linear-gradient(left, #a504f1, #edc03c)\",\"WebkitBackgroundClip\":\"text\",\"WebkitTextFillColor\":\"transparent\"},\"children\":\"QA\"}]]}],[\"$\",\"ol\",null,{\"style\":{\"display\":\"flex\",\"height\":\"60px\",\"lineHeight\":\"60px\",\"marginLeft\":\"200px\"},\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/html.html\",\"children\":\"HTML\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/css.html\",\"children\":\"CSS\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/javascript.html\",\"children\":\"JavaScript\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/framework.html\",\"children\":\"框架\"}]}]]}]]}],[\"$L7\",\"$undefined\",[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]]]}]]}],\"asNotFound\":false,\"children\":[[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"meta\",null,{\"name\":\"baidu-site-verification\",\"content\":\"codeva-IHpkfWdf3A\"}],[\"$\",\"body\",null,{\"className\":\"__className_0ec1f4 love\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"main-nav-container\",\"style\":{\"backgroundColor\":\"#1a1a1b\",\"display\":\"flex\",\"alignItems\":\"center\",\"color\":\"#cecdcd\",\"userSelect\":\"none\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"fontSize\":\"20px\",\"userSelect\":\"none\",\"padding\":\"0 20px\"},\"children\":[[\"$\",\"span\",null,{\"style\":{\"color\":\"#1e9bd3\"},\"children\":\"前端\"}],\" \",[\"$\",\"span\",null,{\"children\":\".\"}],[\"$\",\"span\",null,{\"style\":{\"backgroundImage\":\"-webkit-linear-gradient(left, #a504f1, #edc03c)\",\"WebkitBackgroundClip\":\"text\",\"WebkitTextFillColor\":\"transparent\"},\"children\":\"QA\"}]]}],[\"$\",\"ol\",null,{\"style\":{\"display\":\"flex\",\"height\":\"60px\",\"lineHeight\":\"60px\",\"marginLeft\":\"200px\"},\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/html.html\",\"children\":\"HTML\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/css.html\",\"children\":\"CSS\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/javascript.html\",\"children\":\"JavaScript\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/framework.html\",\"children\":\"框架\"}]}]]}]]}],[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[[\"$\",\"div\",null,{\"style\":{\"margin\":\"40px auto 0\",\"width\":\"700px\"},\"children\":[\" \",[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",[\"category\",\"javascript\",\"d\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$La\",null],\"segment\":\"__PAGE__?{\\\"category\\\":\\\"javascript\\\"}\"},\"styles\":[]}],\" \"]}],null],\"segment\":[\"category\",\"javascript\",\"d\"]},\"styles\":[]}]]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"b:I{\"id\":\"6610\",\"chunks\":[\"862:static/chunks/app/[category]/page-7aa44b034dc500ce.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"a:[\"$\",\"ol\",null,{\"children\":[[\"$\",\"$Lb\",\"0\",{\"question\":\"什么是闭包？ 闭包有哪些优缺点？\",\"answer\":\"\\n        闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。\\n        \\n        作用： 延长变量作用域、在函数的外部可以访问函数内部的局部变量，容易造成内层泄露，因为闭包中的局部变量永远不会被回收\\n        \"}],[\"$\",\"$Lb\",\"1\",{\"question\":\"\\njs 的数据类型有哪些？\\n\",\"answer\":\"\\njs 的数据类型分为基本数据类型（string、number、boolean、null、undefined、symbol）和复杂数据类型\\n基本数据类型的特点：直接存储在栈中的数据\\n\\n复杂数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里\\n\"}],[\"$\",\"$Lb\",\"2\",{\"question\":\"\\n图片懒加载是怎么实现的？\\n\",\"answer\":\"\\n为图片设置默认图或背景图（一般作为骨架屏的一部分），同时监听其在与视口（viewpoint）的位置关系，判断其进入视口时或即将进入视口时，进行图片请求并替换掉默认的图像。\\n\\n关于默认图：可以用真实的图片，也可以通过svg等，也可作为背景图等。\\n关于如何监听图像与视口的位置关系：可以通过监听滚动事件进而计算scrollTop；也可借助Intersection API，这样可以免除额外的计算\\n\"}],[\"$\",\"$Lb\",\"3\",{\"question\":\"\\n什么是symbol ？\\n\",\"answer\":\"\\nES6 引入新的原始数据类型 Symbol，表示独一无二的值\\nSymbol可作为对象的属性名，该属性无法通过常规的Object.keys()或for...in又或Object.getOwnPropertyNames来枚举。因此可以定义一些我们不想对外操作和访问的属性\\n还可用来定义常量，由于天生的唯一性，非常方便。如 const A= Symbol();const B=Symbol()\\n\"}],[\"$\",\"$Lb\",\"4\",{\"question\":\"\\n数据类型的判断有哪些方法？他们的优缺点及区别是什么？\\n\",\"answer\":\"\\ntypeof使用简单，但只能判断基本类型，无法区分object与null\\ninstanceof 只能判断对象是否是某个构造函数的实例\\n通过.constructor 可获取对象的构造器（构造函数）,但改值可以被改写。\\nObject.prototype.toString.call 相对来说功能最全，返回一个字符串：[object Type]\\n\\n\"}],[\"$\",\"$Lb\",\"5\",{\"question\":\"\\n什么是递归，递归有哪些优点或缺点？\\n\",\"answer\":\"\\n递归： 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数\\n优点： 结构清晰、可读性强\\n缺点： 效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。\\n\"}],[\"$\",\"$Lb\",\"6\",{\"question\":\"\\ncall、apply、bind 三者的异同\\n\",\"answer\":\"\\n共同点 :\\n都可以改变 this 指向;\\n不同点:\\ncall 和 apply 会调用函数, 并且改变函数内部 this 指向, 并且call 和 apply传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递\\nbind 不会调用函数, 可以改变函 数内部 this 指向.\\n\\n\"}],[\"$\",\"$Lb\",\"7\",{\"question\":\"\\n什么是深拷贝、什么是浅拷贝？\\n\",\"answer\":\"\\n浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\\n深拷贝： 会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。 深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。\\n\"}],[\"$\",\"$Lb\",\"8\",{\"question\":\"\\njs 的执行机制是怎么样的？\\n\",\"answer\":\"\\njs 是一个单线程、异步、非阻塞 I/O 模型、 event loop 事件循环的执行机制\\n所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。\\n同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入\\\"任务队列\\\"（task queue）的任务，只有\\\"任务队列\\\"通知主线程， 某个异步任务可以执行了，该任务才会进入主线程执行。\"}]]}]\n"])</script><script>self.__next_f.push([1,"7:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n5:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"前端QA集锦\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"前端工程师面试题集锦｜web前端大厂面试真题｜网聚各类前端面试题目\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x"])</script><script>self.__next_f.push([1,"-icon\",\"sizes\":\"any\"}]]\n"])</script></body></html>